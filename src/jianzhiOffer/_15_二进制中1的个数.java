package jianzhiOffer;


/**
 * 输入一个整数，输出该数二进制表示中 1 的个数。
 */
public class _15_二进制中1的个数 {
    /**
     * 常规解法:
     * 为了避免死循环,可以不右移输入的数字n,首先把n和1做与运算,
     * 判断n的最低位是不是1,接着把1左移一位得2,再和n做与运算,就能
     * 判断n的次低位是不是1,这样反复左移,每次都能判断n的其中一位
     * 是不是1,为负数的时候该方法算错
     */
    int NumberOf1(int n){
        int count = 0;
        int flag = 1;
        while(flag > 0){
            if((n & flag) != 0)
                count++;
            flag = flag << 1;
        }
        return count;
    }
    /**
     * 如果一个整数不等于0，那么该整数的二进制表示中至少有一位是1.
     * 假设这个数的最右边一位是1，那么减去1时，最后一位变成0，而其他
     * 所有位都保持不变。也就是最后一位相当于做了取反操作。
     * 假设最后一位是0，如果该整数的二进制表示中最右边的1位于第m位，
     * 那么减去1时，第m位由1变成0，而第m位之后的所有0变成1，整数中
     * 第m位之前的所有位都保持不变。接下来把一个整数和它减去1的结果
     * 做与运算，相当于把它最右边的1变成0，那么就可以解决第m为1的情况。
     * 例如，1100，减去1，得1011，与1100，得1000。
     */
    int NumberOf1_2(int n){
        int count = 0;
        while(n != 0){
            ++count;
            n &= (n - 1);
        }
        return count;
    }


}
