package jianzhiOffer;

/**
 *数组中只出现一次的数字
 * 一个整型数组里除了两个数字之外，其他的数字都出现了两次，找出这两个数。
 * 要求时间复杂度O(N)，空间复杂度O(1)
 */
public class _56_1_两个只出现一次的数字 {
    /**
     * 任何数字异或其自身，得到的结果都是0。也就是说，如果我们从头到尾
     * 依次异或数组中的每个数字，那么最终的结果刚好是那个只出现一次的数字
     * 因为那些成对出现两次的数字全部在异或中抵消了。如果能够把原始数组
     * 分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其它数字
     * 都成对出现两次。我们还是从头到尾依次异或数组中的每个数字，那么最终
     * 得到的结果就是两个只出现一次的数字的异或结果，因为其它数字都出现了
     * 两次，在异或中全部抵消了。由于这两个数字不一样，所有其异或的结果
     * 肯定不为0，也就是说，在这个结果数字的二进制表示中至少有一位1。我们
     * 在结果数字中找到第一个为1的位的位置，记为第n位。现在我们以第n位是不是
     * 1为标准把原始数组分成两部分，第一个子数组中的每个数字的第n位都是1，
     * 而第二个子数组中每个数字的第n位都是0.此两个子数组都只包含了一个只出现一次的
     * 数字，其他数字都是成对出现，因此挨个异或，就可分别在两个子数组中
     * 找到只出现一次的数字。
     */
    public void FindNumsAppearOnce(int[] data, int num1, int num2) {
        if (data == null || data.length < 2)
            return;
        int diff = 0;
        for (int num : data)
            diff ^= num;
        diff &= -diff;//最右侧的不为0的位
        for (int num : data) {
            if ((num & diff) == 0)
                num1 ^= num;
            else
                num2 ^= num;
        }
    }
}
